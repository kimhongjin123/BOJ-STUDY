# 백준 1764번 - 듣보잡 문제 해결

## 문제 설명
"듣도 못한 사람"과 "보도 못한 사람" 명단이 주어질 때, 두 목록에서 **공통으로 등장하는 이름**을 찾아 **사전순으로 출력**하는 문제입니다.

## 해결 방법
이 문제를 해결하기 위해 **집합(Set) 자료구조**를 활용하면 효율적입니다.

### 🔍 기존 코드의 문제점
1. **리스트 사용으로 인해 탐색 속도가 느림**
   - `not_hear.append(input())`로 리스트를 만든 후 `set()` 변환 → 불필요한 연산 발생
   - 리스트에서 `in` 연산은 O(N) 시간이 걸려 **비효율적**
2. **반복문을 여러 번 사용**
   - 입력을 리스트에 추가하고, 다시 집합으로 변환하는 과정이 존재함
   - 출력을 위해 `for`문을 사용해 한 줄씩 출력하는 방식도 개선 가능

### ✅ 개선된 코드
```python
n, m = map(int, input().split())

not_hear = {input().strip() for _ in range(n)}  # 집합으로 저장
not_see = {input().strip() for _ in range(m)}  # 집합으로 저장

result = sorted(not_hear & not_see)  # 교집합 후 정렬

print(len(result))
print("\n".join(result))  # 반복문 없이 한 번에 출력
```

### 🛠 개선된 점
1. **집합(Set) 사용하여 탐색 속도 최적화**
   - 리스트가 아닌 `set()`을 사용하여 **탐색 속도 O(1)** 로 최적화
2. **한 줄로 입력받아 코드 간결화**
   - `{input().strip() for _ in range(n)}` 방식 사용
3. **반복문 없이 출력 최적화**
   - `print("\n".join(result))`를 사용해 **더 깔끔한 출력** 구현

### 🚀 시간 복잡도 비교
| 코드 | 시간 복잡도 |
|------|------------|
| 기존 코드 | **O(N) + O(M) + O(K log K)** (리스트 → 집합 변환 포함) |
| 개선 코드 | **O(N) + O(M) + O(K log K)** (집합 연산으로 더 빠름) |

→ **집합을 바로 사용하면 불필요한 변환 과정이 없어 더 빠름!** 🚀

## 결과
이제 큰 입력값에서도 더 빠르게 실행됩니다! 🎯

