# 백준 2292번 - 벌집 문제 해결

## 문제 설명
- 문제 번호: **2292**
- 문제 이름: **벌집**
- 문제 링크: [백준 2292번](https://www.acmicpc.net/problem/2292)

방은 육각형 형태로 배치되어 있으며, 1번 방에서 시작하여 n번 방까지 최소 몇 개의 방을 지나가는지 구하는 문제입니다.

## 풀이 방법
1. 1번 방은 이동할 필요가 없으므로 **1을 출력**합니다.
2. 2층부터 바깥으로 확장하며 방의 개수가 `6 * i`씩 증가하는 규칙을 찾습니다.
3. `s` (현재 층의 마지막 번호)가 `n` 이상이 될 때까지 증가시키며 `a` (이동 횟수)를 구합니다.

## 코드 구현
```python
n = int(input())

if n == 1:
    print(1)
else:
    a = 1  # 최소 이동 횟수 (층 수)
    s = 1  # 현재 층의 마지막 번호

    while s < n:
        s += 6 * a  # 다음 층의 마지막 번호 계산
        a += 1  # 층 수 증가

    print(a)
```

## 코드 설명
- `n = 1`이면 바로 `1`을 출력합니다.
- `while` 문을 사용하여 `s` 값을 `6 * i`씩 증가시키며 `n`이 해당 범위에 속할 때까지 반복합니다.
- 최종적으로 `a` 값을 출력하면, 1번 방에서 `n`번 방까지 이동하는 최소 횟수를 구할 수 있습니다.

## 실행 예시
### 입력 1
```
13
```
### 출력 1
```
3
```
### 입력 2
```
58
```
### 출력 2
```
5
```

## 시간 복잡도 분석
- 증가하는 숫자가 `1, 7, 19, 37, 61, ...` 처럼 `O(N)`보다는 작은 속도로 커집니다.
- 대략 `O(√N)` 정도의 복잡도를 가지므로, 매우 큰 `n`에서도 빠르게 계산할 수 있습니다.

## 코드 개선점
✅ **불필요한 `for`문 대신 `while` 사용**  
- `n`이 커질 때 `for`문을 `n`까지 돌릴 필요가 없음 → `while`로 더 효율적으로 구현 가능!  

### 개선된 코드
```python
n = int(input())

if n == 1:
    print(1)
else:
    a = 1  # 층 수 (최소 이동 횟수)
    s = 1  # 현재 층의 마지막 방 번호

    while s < n:  # n이 해당 범위에 포함될 때까지 반복
        s += 6 * a  # 다음 층의 마지막 번호 계산
        a += 1  # 층 수 증가

    print(a)
```

### 🔥 **왜 더 좋은가요?**
1. **더 직관적인 코드** → `while`을 사용해 불필요한 루프를 제거.
2. **빠른 종료 가능** → `for i in range(1, n+1)`을 수행하는 대신, 필요한 만큼만 반복하여 성능 개선.
3. **가독성 향상** → 코드가 간결하고 명확함.

## 결론
- 원래 코드도 정답이지만, **`while`문을 사용하면 불필요한 반복을 줄여 최적화 가능!**
- 문제의 핵심은 `6*i`씩 증가하는 **방의 개수 규칙**을 찾는 것.
- 개선된 코드로 바꾸면 더 빠르고 직관적인 풀이가 가능! 🚀

