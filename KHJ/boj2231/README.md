# Baekjoon 2231 - 분해합 문제 해결

## 문제 설명
- **목표**: 주어진 수 `num`에 대해 `num`을 생성할 수 있는 최소의 생성자(분해합)를 구하는 문제입니다.
- 각 수는 자신과 그 자릿수의 합을 더하여 특정 수를 만들 수 있습니다.
- 생성자는 `num = i + sum(자릿수(i))` 형태로 구할 수 있으며, `num`을 만들 수 있는 생성자가 있다면 그 값을 출력합니다. 없으면 `0`을 출력합니다.

## 해결 방법

### 1. 변수 초기화
- `cnt`: 현재 수가 생성자인지 확인하기 위한 변수로, 반복문에서 1부터 시작해 `num`보다 작은 수들을 체크합니다.
- `sum_digits`: 각 수 `i`의 자릿수 합을 계산합니다.

### 2. 규칙 찾기
- 주어진 수 `num`에 대해, 각 수 `i`의 자릿수 합을 더한 값이 `num`과 일치하는지 확인해야 합니다.
- 예시: 100을 만들기 위한 수는 `91`로, `91 + (9 + 1) = 100`입니다.

### 3. 반복문 수행
- `i`를 1부터 `num`까지 돌면서, 각 `i`의 자릿수 합을 구하고 그것이 `num`과 같으면 `i`는 생성자입니다.
- `num`보다 작은 수들만 검사하므로, `i`가 `num`을 초과할 경우 더 이상 검사를 진행하지 않습니다.

---

## 코드 구현

```python
num = int(input())  # 입력받은 num 값
ls = []  # 생성자를 저장할 리스트

# 1부터 num까지 순차적으로 검사
for i in range(1, num + 1):
    cons = i + sum(map(int, list(str(i))))  # i와 i의 자릿수 합을 더한 값 계산
    if num == cons:  # 생성자일 경우
        ls.append(i)  # 생성자 i를 리스트에 추가

# 생성자가 있으면 첫 번째 생성자 출력, 없으면 0 출력
if not ls:
    print(0)
else:
    print(ls[0])
```
## 코드 설명
1. **입력 받기**: `num`을 입력받습니다.
2. **반복문 수행**: 
   - `i`를 1부터 `num`까지 돌며 `i`와 `i`의 자릿수 합을 더한 값 `cons`를 계산합니다.
   - `num == cons`이면 `i`가 생성자이므로, 이를 리스트 `ls`에 저장합니다.
3. **결과 출력**: 
   - 리스트 `ls`에 생성자가 있으면 첫 번째 생성자(`ls[0]`)를 출력하고, 없으면 `0`을 출력합니다.

---

## 개선점
- **무한 루프 개선**: `while True`와 같은 무한 루프를 사용하는 대신, `for i in range(1, num + 1)` 방식으로 범위를 명시하여 코드의 가독성을 향상시켰습니다.
- **조건문 단순화**: `else` 문을 제거하고 `if not ls`로 처리하여 불필요한 코드를 줄였습니다.
- **자릿수 합 계산 방식**: `sum(map(int, list(str(i))))`로 자릿수 합을 계산하는 방식을 사용하여 코드가 간결해졌습니다.

---

## 시간 복잡도 분석
- `i`는 1부터 `num`까지 전부 검사하므로 **O(N)** 시간 복잡도를 가집니다.
- 각 수 `i`에 대해 자릿수 합을 계산하는 데는 `O(log N)` 시간이 들지만, 전체 시간 복잡도는 **O(N log N)**으로, 큰 값에서도 충분히 실행 가능합니다.
  
- **최악의 경우**: `num`이 1,000,000일 경우에도 효율적으로 실행할 수 있습니다. 하지만 `num`이 매우 클 경우 성능을 고려해 더 효율적인 알고리즘을 사용해야 할 수 있습니다.
