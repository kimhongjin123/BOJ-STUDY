# BOJ 150829 - Hashing

## 문제 설명
- 주어진 문자열을 특정 해싱 방식으로 변환하여 값을 계산하는 문제입니다.
- 각 문자에 해당하는 숫자 값을 부여하고, 특정 수(31)를 거듭제곱하여 더한 후 특정 모듈로 나눈 값을 출력합니다.

## 코드 설명
```python
a = int(input())
b = list(input())
c = [(ord(i) - 96) for i in b]  # 알파벳을 숫자로 변환 (a=1, b=2, ..., z=26)
sum = 0
for i in range(0, a):
    sum += c[i] * 31 ** i  # 거듭제곱을 활용한 해싱 계산
print(sum % 1234567891)  # 모듈러 연산을 적용하여 결과 출력
```

## 코드 동작 방식
1. **입력 받기**
   - 첫 번째 줄에서 정수 `a`를 입력받아 문자열의 길이를 저장합니다.
   - 두 번째 줄에서 문자열을 입력받아 리스트 `b`에 저장합니다.

2. **문자 -> 숫자 변환**
   - `ord(i) - 96`을 사용하여 알파벳을 숫자로 변환합니다.
     - 예: 'a' -> 1, 'b' -> 2, ..., 'z' -> 26

3. **해싱 값 계산**
   - `sum += c[i] * 31 ** i` 를 통해 각 문자의 값을 거듭제곱하여 가중치를 부여합니다.
   - 기본 해싱 방식에서 사용하는 소수 31을 사용하여 충돌 가능성을 낮춥니다.

4. **모듈러 연산 적용**
   - `sum % 1234567891`을 적용하여 값이 너무 커지는 것을 방지합니다.

## 입출력 예시
### 입력
```
5
abcde
```
### 변환 과정
- `a = 1, b = 2, c = 3, d = 4, e = 5`
- 해싱 계산: `1*31^0 + 2*31^1 + 3*31^2 + 4*31^3 + 5*31^4`
- 결과를 `1234567891`로 나눈 나머지를 출력

### 출력
```
4739715
```

## 시간 복잡도
- **O(n)**: 문자열의 길이만큼 반복하므로 선형 시간 복잡도를 가집니다.

## 추가 개선점
- `pow(31, i, 1234567891)`를 활용하면 거듭제곱 연산 시 모듈러 연산을 적용하여 **연산 속도를 개선**할 수 있습니다.

