
# 백준 2775번 문제: 부녀회장이 될테야

## 문제 설명

이 문제는 `a`층의 `b`호에 사는 사람의 수를 구하는 문제입니다. 규칙에 따라 주어진 층과 호에 있는 사람 수를 계산해야 합니다. 각 층의 사람 수는 아래와 같이 정의됩니다:

- `0층`의 `n`호에는 `n`명이 살고 있습니다.
- 그 외의 각 층 `k`에서, `n`호에 살고 있는 사람의 수는 `(k-1)`층의 `1`호부터 `n`호까지의 사람 수의 합입니다.

## 문제 해결 방식

1. **재귀적 접근 (주석 포함)**

   첫 번째로 작성한 코드는 재귀 방식을 사용하여 문제를 해결했습니다. 그러나 재귀 방식은 메모리 사용과 성능 측면에서 비효율적일 수 있습니다. 이를 리뷰하고 개선해 보겠습니다.

### 재귀 코드 (주석 포함)

```python
# 재귀 방식으로 풀었던 코드
def test(a, b):
    sum = 0
    if a == 0:  # 0층이라면, 해당 호는 사람 수가 b와 같음
        sum += b
        return sum
    
    for i in range(1, b + 1):  # 해당 호의 사람 수를 구하기 위해 이전 층들을 호출
        sum += test(a - 1, i)

    return sum

for i in range(int(input())):
    a, b = [int(input()) for _ in range(2)]  # a, b 값 입력
    print(test(a, b))  # 재귀 호출을 통해 결과 출력
```

#### 재귀 코드 리뷰:

- **재귀 호출의 문제점**:
  - `test(a, b)` 함수는 `a`층의 `b`호에 대한 사람 수를 계산하기 위해 `test(a-1, i)`를 반복적으로 호출합니다. 이 방식은 각 호출마다 여러 번의 하위 호출을 생성하여 스택 오버플로우나 비효율적인 메모리 사용을 초래할 수 있습니다.
  - `a`와 `b` 값이 커지면, 중복된 계산이 발생하여 성능이 크게 떨어질 수 있습니다. 예를 들어, 동일한 `a`와 `b`에 대해 여러 번 계산이 이루어집니다.
  - 이러한 재귀 방식은 시간 복잡도가 `O(a * b)`로 비효율적일 수 있습니다.

---

2. **동적 계획법 (최적화된 해결책)**

   재귀적 접근 대신, 동적 계획법(DP)을 사용하여 문제를 해결할 수 있습니다. `L2` 배열을 사용하여 각 층과 호에 대해 계산된 값을 저장하고, 이전 계산을 재사용하는 방식입니다.

### 동적 계획법 코드

```python
def solve():
    # 각 테스트 케이스마다 실행
    for _ in range(int(input())):
        a, b = map(int, input().split())
        
        # 15층, 15호 배열 초기화
        L2 = [[0] * 15 for _ in range(a + 1)]

        # 0층 초기화 (1호부터 14호까지는 1명씩)
        for i in range(1, 15):
            L2[0][i] = i
        
        # 각 층의 사람 수 계산
        for i in range(1, a + 1):
            for j in range(1, 15):
                L2[i][j] = L2[i][j - 1] + L2[i - 1][j]

        # 결과 출력
        print(L2[a][b])

# 함수 실행
solve()
```

#### 동적 계획법 코드 리뷰:

- **동적 계획법 사용**:
  - DP 배열 `L2[a][b]`를 사용하여 각 층과 호에 대한 사람 수를 저장합니다. 이를 통해 이전에 계산한 값을 재사용할 수 있습니다.
  - `0층`의 각 호에는 해당 호 번호만큼 사람이 살고 있으므로 초기화하고, 그 이후 `a`층에서 `b`호의 사람 수를 계산합니다.
  - 이 방식은 중복 계산을 피하고, 메모리를 절약하며, 시간 복잡도를 `O(a * b)`로 줄여줍니다.
  - 배열 크기는 `15 * 15`로 고정되어 있으며, `a`와 `b` 값이 최대 14까지 필요하므로 효율적입니다.

---

## 개선된 코드

```python
def solve():
    # 각 테스트 케이스마다 실행
    for _ in range(int(input())):
        a, b = map(int, input().split())
        
        # 15층, 15호 배열 초기화
        L2 = [[0] * 15 for _ in range(a + 1)]

        # 0층 초기화 (1호부터 14호까지는 1명씩)
        for i in range(1, 15):
            L2[0][i] = i
        
        # 각 층의 사람 수 계산
        for i in range(1, a + 1):
            for j in range(1, 15):
                L2[i][j] = L2[i][j - 1] + L2[i - 1][j]

        # 결과 출력
        print(L2[a][b])

# 함수 실행
solve()
```

### 개선 사항:
1. **배열 초기화 및 계산 방식**: 배열 크기를 고정하여 메모리 낭비를 줄였습니다.
2. **입력 처리**: `map()`과 `split()`을 사용하여 한 번에 `a`, `b` 값을 처리했습니다.
3. **반복문 최적화**: 불필요한 중복 `for`문을 제거하고, 코드의 가독성을 높였습니다.

